# -*- coding: utf-8 -*-
"""SARIMAX Model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14bYwoRheQp-1_ujW14xw0Lqkqk_Cnvhp
"""

import pandas as pd

# Read crop data
df = pd.read_csv('/content/drive/MyDrive/Adamson U/Courses/THESIS/Model/csv/df_ARIMA_final_allocation_new_test1.csv')
df.info()
df.plot(kind='line', figsize=(20, 6))

# Read weather data
df_weather = pd.read_csv('/content/drive/MyDrive/Adamson U/Courses/THESIS/Model/csv/weather data.csv')
df_weather.info()
df_weather.plot(kind='line', figsize=(20, 6))

# CUT THE WEATHER DATA (:-36 to remove 3 years for testing)
df_weather = df_weather.iloc[:-36]

# Logarithmic values
import numpy as np
df = np.log(df)
df.plot(kind='line', figsize=(20, 6))

# Mask the data (Training | Testing)
msk = (df.index < len(df)-36)
df_train = df[msk].copy()
df_test  = df[~msk].copy()

# Data visualization (Training | Testing)
print('training:',len(df_train))
df_train.plot(figsize = (10,5))
print('testing:',len(df_test))
df_test.plot(figsize = (10,5))

"""#STEP 1: Check for stationary of Time Series

Method #1: time series plot

Method #2: ACF plot and PACF plot
"""

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

acf_original = plot_acf(df_train)
pacf_original = plot_pacf(df_train)

"""Method #3: ADF Test"""

from statsmodels.tsa.stattools import adfuller

adf_test = adfuller(df_train)
print(f'p-value {adf_test[1]}')

"""#Transform to stationary: differencing
Only use if p-value > 0.05
"""

df_train_diff = df_train.diff().dropna()
df_train_diff.plot()

acf_original = plot_acf(df_train_diff)
pacf_original = plot_pacf(df_train_diff)

adf_test = adfuller(df_train_diff)
print(f'p-value {adf_test[1]}')

"""#Step 2: Determine ARIMA"""

pip install pmdarima

# MANUAL SARIMA (determine p,d,q)
from pmdarima import auto_arima
# Ignore harmless warnings
import warnings
warnings.filterwarnings("ignore")

stepwise_fit = auto_arima(df_train, trace = True, supress_warnings = True, seasonal = True, m = 12, exog = df_weather[['Temperature (C)', 'Humidity (%)', 'rain 1h']])
stepwise_fit.summary()

# Get the identified orders for SARIMA
(p, d, q) = stepwise_fit.order
(P, D, Q, m) = stepwise_fit.seasonal_order

# Print the identified orders
print(f"Non-seasonal order (p, d, q): ({p}, {d}, {q})")
print(f"Seasonal order (P, D, Q, m): ({P}, {D}, {Q}, {m})")

from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.arima.model import ARIMA

model = SARIMAX(df_train, order = (p,d,q), seasonal_order=(P,D,Q,m), exog = df_weather[['Temperature (C)', 'Humidity (%)', 'rain 1h']])
model_fit = model.fit()
print(model_fit.summary())

"""#Step 4: Make time series predictions"""

import matplotlib.pyplot as plt
residuals = model_fit.resid[1:]
fig, ax = plt.subplots(1,2)
residuals.plot(title = 'Residuals', ax = ax[0])
residuals.plot(title = 'Density', kind = 'kde', ax = ax[1])
plt.show()

acf_res = plot_acf(residuals)
pacf_res = plot_pacf(residuals)

df_weather_test = df_weather.iloc[-36:]

forecast_test = model_fit.forecast(steps=len(df_test), exog = df_weather_test[['Temperature (C)', 'Humidity (%)', 'rain 1h']])
forecast_test

df_train = df_train.rename(columns={'0': '1987 - 2019'})

# Assuming df_train and forecast_test are both Series
merged_data = pd.concat([df_train, forecast_test])

# If you want to reset the index, you can do:
merged_data.reset_index(drop=True, inplace=True)

# Now, merged_data contains both df_train and forecast_test
print(merged_data)

# Plot original value and predicted test value (for comparison)
df_merged_data = pd.concat([df, forecast_test])
df_merged_data = df_merged_data.iloc[396:] # Get only the forecast point for graph

df_merged_data.plot(figsize=(20, 6))

"""#Step 5: Evaluate model predictions

Mean Absolute Error

The Mean Absolute Error (MAE) is a common metric used to evaluate the accuracy of forecasts generated by time series models, including the Autoregressive Integrated Moving Average (ARIMA) model. MAE measures the average absolute difference between the actual observed values and the predicted values from the model.
"""

from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, mean_squared_error
import numpy as np
import pandas as pd
from scipy import stats

# Un-log the value using the exponential function
df_test = np.exp(df_test)
forecast_test = np.exp(forecast_test)

# Perform the paired T-test
df = pd.read_csv('/content/drive/MyDrive/Adamson U/Courses/THESIS/Model/csv/df_ARIMA_final_allocation_new_test1.csv')
df_t_test = pd.concat([df.iloc[396:], forecast_test], axis=1)

t_statistic, p_value = stats.ttest_rel(df_t_test['0'], df_t_test['predicted_mean'])

print("T-Statistic:", t_statistic)
print("P-Value:", p_value)

# MANUAL ARIMA
mae = mean_absolute_error(df_test, forecast_test)
mape = mean_absolute_percentage_error (df_test, forecast_test)
rmse = np.sqrt(mean_squared_error(df_test, forecast_test))

print(f'mae - manual: {mae}')
print( f'mape - manual: {mape}')
print(f'rmse - manual: {rmse}')

"""#Predicting Future Values"""

df = pd.read_csv('/content/drive/MyDrive/Adamson U/Courses/THESIS/Model/csv/df_ARIMA_final_allocation_new_test1.csv')
df_weather = pd.read_csv('/content/drive/MyDrive/Adamson U/Courses/THESIS/Model/csv/weather data.csv')
df_weather_predicted = pd.read_csv('/content/drive/MyDrive/Adamson U/Courses/THESIS/Model/csv/weather data [predicted].csv')

model2 = SARIMAX(df, order = (p,d,q), seasonal_order = (P,D,Q,m), exog = df_weather[['Temperature (C)', 'Humidity (%)', 'rain 1h']])
model2 = model2.fit()
df.tail

pred = model2.predict(start = len(df), end = len(df)+11, type = 'levels', exog = df_weather_predicted[['Temperature (C)', 'Humidity (%)', 'rain 1h']]).rename('SARIMAX Predictions')
print(pred)

df.plot()
pred.plot(figsize=(20,5), legend=True)

pred

print("2023 Prediction for Rainfed Palay harvest (Nueva Ecija): ", pred.sum(), 'Hta')

"""#DATA VISUALIZATION (Compilation)"""

# Set your start and end dates
start_date = '1987-01-01'
end_date = '2022-12-31'

# Create a date range using pd.date_range
date_range = pd.date_range(start=start_date, end=end_date, freq='M')

# ORIGINAL DATA
df_visualization = df
df_visualization = df_visualization.rename(columns={'0': '1987 - 2022'})
df_visualization.index = date_range

print(df_visualization)
df_visualization.plot(figsize=(20, 6))

# FORECAST (TEST)
merged_data_visualization = merged_data
merged_data_visualization.index = date_range

# Logarithmically transformed value
x_log = merged_data_visualization  # Replace with your actual log-transformed value

# Un-log the value using the exponential function
merged_data_visualization = np.exp(x_log)

print(merged_data_visualization)
merged_data_visualization.plot(figsize=(20, 6))

# FORECAST DATA (2023)
# Set your start and end dates
start_date = '1987-01-01'
end_date = '2023-12-31'

# Create a date range using pd.date_range
date_range = pd.date_range(start=start_date, end=end_date, freq='M')

df = df.rename(columns={'0': '1987 - 2022'})

# Assuming df_train and forecast_test are both Series
merged_data_prediction = pd.concat([df, pred])

# If you want to reset the index, you can do:
merged_data_prediction.reset_index(drop=True, inplace=True)

merged_data_prediction.index = date_range

print(merged_data_prediction.tail(12))
print("2023 Prediction for Rainfed Palay harvest (Nueva Ecija): ", pred.sum(), 'Hta')
merged_data_prediction.plot(figsize=(20, 6))

